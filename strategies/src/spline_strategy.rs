//! # Spline Strategy
//! 
//! This strategy uses mathematical splines to model recent price movements and predict future price direction.
//! By fitting a smooth curve to historical price data, it aims to identify subtle trends and inflections that might not be apparent with simpler indicators.
//! 
//! The strategy continuously updates a spline based on incoming trade data. Signals are generated by comparing the predicted price at the current timestamp
//! with a slightly earlier predicted price. A significant positive difference suggests an upward trend (buy signal),
//! while a significant negative difference suggests a downward trend (sell signal).

use trade::models::TradeData;
use trade::trader::Position;
use crate::strategy::Strategy;
use trade::signal::Signal;
use tracing::{debug, info};
pub use splines::{Interpolation, Key, Spline};

pub struct SplineStrategy {
    pub window_size: usize,
    pub prices: Vec<f64>,
    pub timestamps: Vec<f64>,
    pub last_spline: Option<Spline<f64, f64>>,
    pub interpolation: Interpolation<f64, f64>,
}

impl SplineStrategy {
    pub fn new(window_size: usize, interpolation: Interpolation<f64, f64>) -> Self {
        Self {
            window_size,
            prices: Vec::with_capacity(window_size),
            timestamps: Vec::with_capacity(window_size),
            last_spline: None,
            interpolation,
        }
    }

    // Build spline only if we have enough data
    pub fn update_spline(&mut self) {
        if self.prices.len() == self.window_size {
            let points: Vec<_> = self
                .timestamps
                .iter()
                .zip(self.prices.iter())
                .map(|(&t, &p)| Key::new(t, p, self.interpolation))
                .collect();
            self.last_spline = Some(Spline::from_vec(points));
            debug!(spline_points = self.window_size, "Spline updated.");
        } else {
            self.last_spline = None;
            info!(
                need_data = self.window_size,
                have_data = self.prices.len(),
                "Waiting for enough data to build spline."
            );
        }
    }
}

#[async_trait::async_trait]
impl Strategy for SplineStrategy {
    async fn on_trade(&mut self, trade: TradeData) {
        let price = trade.price;
        let timestamp = trade.time as f64;

        self.prices.push(price);
        self.timestamps.push(timestamp);

        if self.prices.len() > self.window_size {
            self.prices.remove(0);
            self.timestamps.remove(0);
        }
        self.update_spline();
    }

    fn get_signal(
        &self,
        _current_price: f64,
        _current_timestamp: f64, // Not used directly, we use last_ts
        _current_position: Position,
    ) -> (Signal, f64) {
        debug!("Entering get_signal");

        if self.last_spline.is_none() {
            debug!("No spline available, returning Hold");
            return (Signal::Hold, 0.0);
        }

        let price_difference_threshold = 0.000000000000001; // Extremely small threshold for HFT
        let epsilon = 60_000_000_000.0; // 1 minute in nanoseconds

        let spline = self.last_spline.as_ref().unwrap(); // We already checked for None above

        let last_ts = *self.timestamps.last().unwrap();

        let price_difference = {
            let p_now_ts = last_ts;
            let p_prev_ts = last_ts - epsilon;

            // Ensure p_prev_ts is not before the first timestamp in the spline
            if p_prev_ts < *self.timestamps.first().unwrap() {
                debug!(p_prev_ts = p_prev_ts, first_spline_timestamp = *self.timestamps.first().unwrap(), "p_prev_ts is before the first spline timestamp. Returning Hold.");
                return (Signal::Hold, 0.0);
            }

            debug!(p_now_ts = format!("{:.0}", p_now_ts), "Sampling spline at p_now_ts.");
            let p_now = match spline.sample(p_now_ts) {
                Some(p) => p,
                None => {
                    debug!(p_now_ts = format!("{:.0}", p_now_ts), "Spline sample at p_now_ts returned None. Returning Hold.");
                    return (Signal::Hold, 0.0);
                }
            };

            debug!(p_prev_ts = format!("{:.0}", p_prev_ts), "Sampling spline at p_prev_ts.");
            let p_prev = match spline.sample(p_prev_ts) {
                Some(p) => p,
                None => {
                    debug!(p_prev_ts = format!("{:.0}", p_prev_ts), "Spline sample at p_prev_ts returned None. Returning Hold.");
                    return (Signal::Hold, 0.0);
                }
            };
            p_now - p_prev
        };

        info!(ts = format!("{:.0}", last_ts), difference = format!("{:.6}", price_difference), "Price difference calc.");

        let signal: Signal;
        let mut confidence: f64 = 0.0;

        if price_difference > price_difference_threshold {
            debug!(
                signal = "Buy",
                difference = format!("{:.6}", price_difference),
                threshold = format!("{:.6}", price_difference_threshold),
                "Signal: Buy"
            );
            signal = Signal::Buy;
            confidence = ((price_difference - price_difference_threshold) / (price_difference_threshold * 10.0)).min(1.0); // Example confidence calculation
        } else if price_difference < -price_difference_threshold {
            debug!(
                signal = "Sell",
                difference = format!("{:.6}", price_difference),
                threshold = format!("{:.6}", price_difference_threshold),
                "Signal: Sell"
            );
            signal = Signal::Sell;
            confidence = ((price_difference.abs() - price_difference_threshold) / (price_difference_threshold * 10.0)).min(1.0); // Example confidence calculation
        } else {
            debug!(
                signal = "Hold",
                difference = format!("{:.6}", price_difference),
                threshold = format!("{:.6}", price_difference_threshold),
                "Signal: Hold"
            );
            signal = Signal::Hold;
            confidence = 0.0;
        }
        (signal, confidence)
    }
}
