//! # Spline Strategy (HFT Adapted)
//!
//! This strategy uses mathematical splines to model recent price movements and predict future price direction.
//! Adapted for High-Frequency Trading (HFT), it focuses on efficient data handling and rapid signal generation
//! by analyzing the derivative of the spline to detect momentum.
//!
//! The strategy continuously updates a spline based on incoming trade data. Signals are generated by
//! evaluating the first derivative of the spline at the current time. A positive derivative exceeding
//! a threshold indicates upward momentum (buy signal), while a negative derivative below a threshold
//! indicates downward momentum (sell signal).

use trade::models::TradeData;
use trade::trader::Position;
use crate::strategy::Strategy;
use trade::signal::Signal;
use async_trait::async_trait;
use std::collections::VecDeque;
pub use splines::{Interpolation, Key, Spline};
use tracing::{debug, info};

#[derive(Clone)]
pub struct SplineStrategy {
    pub window_size: usize,
    pub prices: VecDeque<f64>,
    pub timestamps: VecDeque<f64>,
    pub last_spline: Option<Spline<f64, f64>>,
    pub interpolation: Interpolation<f64, f64>,
    pub derivative_buy_threshold: f64,
    pub derivative_sell_threshold: f64,
}

impl SplineStrategy {
    pub fn new(
        window_size: usize,
        interpolation: Interpolation<f64, f64>,
        derivative_buy_threshold: f64,
        derivative_sell_threshold: f64,
    ) -> Self {
        Self {
            window_size,
            prices: VecDeque::with_capacity(window_size),
            timestamps: VecDeque::with_capacity(window_size),
            last_spline: None,
            interpolation,
            derivative_buy_threshold,
            derivative_sell_threshold,
        }
    }

    // Build spline only if we have enough data
    // This function will be called on every trade for simplicity, but VecDeque makes it efficient.
    pub fn update_spline(&mut self) {
        if self.prices.len() == self.window_size {
            let points: Vec<_> = self
                .timestamps
                .iter()
                .zip(self.prices.iter())
                .map(|(&t, &p)| Key::new(t, p, self.interpolation))
                .collect();
            self.last_spline = Some(Spline::from_vec(points));
            debug!(spline_points = self.window_size, "Spline updated.");
        } else {
            self.last_spline = None;
            info!(
                need_data = self.window_size,
                have_data = self.prices.len(),
                "Waiting for enough data to build spline."
            );
        }
    }
}

#[async_trait]
impl Strategy for SplineStrategy {
    async fn on_trade(&mut self, trade: TradeData) {
        let price = trade.price;
        let timestamp = trade.time as f64;

        self.prices.push_back(price);
        self.timestamps.push_back(timestamp);

        if self.prices.len() > self.window_size {
            self.prices.pop_front();
            self.timestamps.pop_front();
        }
        self.update_spline();
    }

    fn get_signal(
        &self,
        _current_price: f64, // Not directly used for signal, but can be for confidence
        _current_timestamp: f64,
        _current_position: Position,
    ) -> (Signal, f64) {
        debug!("Entering get_signal for SplineStrategy");

        if self.last_spline.is_none() || self.timestamps.is_empty() {
            debug!("No spline available or no timestamps, returning Hold");
            return (Signal::Hold, 0.0);
        }

        let spline = self.last_spline.as_ref().unwrap();
        let current_ts = *self.timestamps.back().unwrap(); // Use the latest timestamp

        // Calculate the first derivative at the current timestamp
        let epsilon = 1.0; // A small time difference for derivative calculation

        let price_now = match spline.sample(current_ts) {
            Some(p) => p,
            None => {
                debug!(current_ts = format!("{:.0}", current_ts), "Spline sample at current_ts returned None. Returning Hold.");
                return (Signal::Hold, 0.0);
            }
        };

        let price_prev = match spline.sample(current_ts - epsilon) {
            Some(p) => p,
            None => {
                debug!(current_ts_minus_epsilon = format!("{:.0}", current_ts - epsilon), "Spline sample at current_ts - epsilon returned None. Returning Hold.");
                return (Signal::Hold, 0.0);
            }
        };

        let derivative = (price_now - price_prev) / epsilon;

        info!(ts = format!("{:.0}", current_ts), derivative = format!("{:.6}", derivative), "Spline derivative calculated.");

        let signal: Signal;
        let confidence: f64;

        if derivative > self.derivative_buy_threshold {
            debug!(
                signal = "Buy",
                derivative = format!("{:.6}", derivative),
                threshold = format!("{:.6}", self.derivative_buy_threshold),
                "Signal: Buy"
            );
            signal = Signal::Buy;
            // Confidence based on how much the derivative exceeds the threshold
            confidence = ((derivative - self.derivative_buy_threshold) / (self.derivative_buy_threshold * 10.0)).min(1.0);
        } else if derivative < self.derivative_sell_threshold {
            debug!(
                signal = "Sell",
                derivative = format!("{:.6}", derivative),
                threshold = format!("{:.6}", self.derivative_sell_threshold),
                "Signal: Sell"
            );
            signal = Signal::Sell;
            // Confidence based on how much the derivative is below the threshold
            confidence = ((self.derivative_sell_threshold - derivative) / (self.derivative_sell_threshold.abs() * 10.0)).min(1.0);
        } else {
            debug!(
                signal = "Hold",
                derivative = format!("{:.6}", derivative),
                buy_threshold = format!("{:.6}", self.derivative_buy_threshold),
                sell_threshold = format!("{:.6}", self.derivative_sell_threshold),
                "Signal: Hold"
            );
            signal = Signal::Hold;
            confidence = 0.0;
        }
        (signal, confidence)
    }
}