//! # Spline Strategy (HFT Adapted)
//!
//! This strategy uses mathematical splines to model recent price movements and predict future price direction.
//! Adapted for High-Frequency Trading (HFT), it focuses on efficient data handling and rapid signal generation
//! by analyzing the derivative of the spline to detect momentum.
//!
//! The strategy continuously updates a spline based on incoming trade data. Signals are generated by
//! evaluating the first derivative of the spline at the current time. A positive derivative exceeding
//! a threshold indicates upward momentum (buy signal), while a negative derivative below a threshold
//! indicates downward momentum (sell signal).

use trade::models::TradeData;
use trade::trader::Position;
use crate::strategy::Strategy;
use trade::signal::Signal;
use crate::config::StrategyConfig;
use async_trait::async_trait;
use std::collections::VecDeque;
pub use splines::{Interpolation, Key, Spline};
use tracing::{debug, info};

#[derive(Clone)]
pub struct SplineStrategy {
    pub window_size: usize,
    pub prices: VecDeque<f64>,
    pub timestamps: VecDeque<f64>,
    pub last_spline: Option<Spline<f64, f64>>,
    pub interpolation: Interpolation<f64, f64>,
    pub derivative_buy_threshold: f64,
    pub derivative_sell_threshold: f64,
    pub scale: f64,
    // Configuration parameters
    pub signal_threshold: f64,
    pub momentum_threshold: f64,
    pub last_price: f64,
    pub price_momentum: f64,
}

impl SplineStrategy {
    pub fn new() -> Self {
        let config = StrategyConfig::load_strategy_config("spline_strategy");
        
        let window_size = config.as_ref().map(|c| c.get_or("window_size", 20)).unwrap_or(20);
        let derivative_buy_threshold = config.as_ref().map(|c| c.get_or("derivative_buy_threshold", 0.001)).unwrap_or(0.001);
        let derivative_sell_threshold = config.as_ref().map(|c| c.get_or("derivative_sell_threshold", -0.001)).unwrap_or(-0.001);
        let scale = config.as_ref().map(|c| c.get_or("scale", 1.2)).unwrap_or(1.2);
        let signal_threshold = config.as_ref().map(|c| c.get_or("signal_threshold", 0.3)).unwrap_or(0.3);
        let momentum_threshold = config.as_ref().map(|c| c.get_or("momentum_threshold", 0.0001)).unwrap_or(0.0001);
        
        let interpolation = Interpolation::Linear;

        Self {
            window_size,
            prices: VecDeque::with_capacity(window_size),
            timestamps: VecDeque::with_capacity(window_size),
            last_spline: None,
            interpolation,
            derivative_buy_threshold,
            derivative_sell_threshold,
            scale,
            signal_threshold,
            momentum_threshold,
            last_price: 0.0,
            price_momentum: 0.0,
        }
    }

    // Build spline only if we have enough data
    // This function will be called on every trade for simplicity, but VecDeque makes it efficient.
    pub fn update_spline(&mut self) {
        if self.prices.len() == self.window_size {
            let points: Vec<_> = self
                .timestamps
                .iter()
                .zip(self.prices.iter())
                .map(|(&t, &p)| Key::new(t, p, self.interpolation))
                .collect();
            self.last_spline = Some(Spline::from_vec(points));
            debug!(spline_points = self.window_size, "Spline updated.");
        } else {
            self.last_spline = None;
            info!(
                need_data = self.window_size,
                have_data = self.prices.len(),
                "Waiting for enough data to build spline."
            );
        }
    }
}

#[async_trait]
impl Strategy for SplineStrategy {
    fn get_info(&self) -> String {
        format!("Spline Strategy (window_size: {}, derivative_buy_threshold: {}, derivative_sell_threshold: {}, scale: {})", self.window_size, self.derivative_buy_threshold, self.derivative_sell_threshold, self.scale)
    }

    async fn on_trade(&mut self, trade: TradeData) {
        let price = trade.price;
        let timestamp = trade.time as f64;

        // Update price momentum
        if self.last_price > 0.0 {
            self.price_momentum = (price - self.last_price) / self.last_price;
        }

        self.prices.push_back(price);
        self.timestamps.push_back(timestamp);

        if self.prices.len() > self.window_size {
            self.prices.pop_front();
            self.timestamps.pop_front();
        }
        self.update_spline();
        
        self.last_price = price;
    }

    fn get_signal(
        &self,
        _current_price: f64, // Not directly used for signal, but can be for confidence
        _current_timestamp: f64,
        _current_position: Position,
    ) -> (Signal, f64) {
        debug!("Entering get_signal for SplineStrategy");

        if self.last_spline.is_none() || self.timestamps.is_empty() {
            debug!("No spline available or no timestamps, returning Hold");
            return (Signal::Hold, 0.0);
        }

        // Pure momentum approach like successful strategies (ignore spline derivative)
        let momentum_factor = if self.price_momentum.abs() > self.momentum_threshold { 2.5 } else { 1.0 };
        let momentum_strength = (self.price_momentum * 3000.0).min(1.0);

        let signal: Signal;
        let confidence: f64;

        if self.price_momentum > self.momentum_threshold {
            signal = Signal::Buy;
            confidence = momentum_strength * momentum_factor * self.scale;
        } else if self.price_momentum < -self.momentum_threshold {
            signal = Signal::Sell;
            confidence = momentum_strength * momentum_factor * self.scale;
        } else {
            signal = Signal::Hold;
            confidence = 0.0;
        }

        // Apply signal threshold filter
        if confidence < self.signal_threshold {
            return (Signal::Hold, 0.0);
        }

        (signal, confidence.min(1.0))
    }
}